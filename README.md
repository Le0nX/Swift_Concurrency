# Swift_Concurrency
Конспект по многопоточности в iOS.

## Содержание
* [Обзор GCD и Operations](gcd-&-operations)
* [О Dispatch Queue подробно](dispatch-queue)

## GCD & Operations
В iOS представлены два основных способа взаимодействия с монгопоточностью:
* Grand Central Dispatch (**GCD**)
* Operations

GCD представляет из себя пулл потоков, которые менеджатся самой системой, и FIFO очереди с блоками(closures), которые отдаются на исполнение пулу потоков. Нет никакой гарантии какой именно поток возьмется за исполнение блока. 

### Синхронность и асинхронность
Блок может быть передан в очередь на синхронное или асинхронное исполнение. Если блок был передан в очередь на синхронное исоплнение, то текущий цикл будет заблокирован до тех пор, пока блок не будет полностью исполнен. В случае асинхронного исполнения блокировки не происходит и после передачи блока на асинхронное исполнение, управление сразу возвращается текущему циклу - в этом случае приложение может продолжать выполнять свои другие задачи, пока асинхронно исполняется наш блок. 

**Важно помнить, что FIFO не гарантирует нам порядок *завершения* задач. Единственная гарантия, которую мы получаем - порядок *начала* исполнения задач.**

В целом мы будем стремиться добавить все тяжелые таски не связанные с UI в асинхронную background очередь. 

```swift
// создаем очередь со своей уникальной меткой
let queue = DispatchQueue(label: "com.nefedov.denis")
// Дальше где-то в функции
queue.async {
 // вызываем медленные non-UI таски здесь
 DispatchQueue.main.async {
    // Здесь обновляем UI
 } 
}
```

### Последовательные и параллельные очереди
Очередь, в которую мы можем добавить наши блоки(таски), бывает последовательной и параллельной. Очевидно, что последовательная очередь использует только один поток для исполнения тасков, в то время как параллельная очередь может использовать несколько потоков для исполнения задач. Однако, **нет никакой гарантии, что параллельная очередь будет всегда использовать больше одного потока** для исполнения задач. Если система очень сильно нагружена, то нам будет выделен только один поток. 

### Асинхронность не означает параллелизм
Добавление таска в асинхронную очередь вовсе не означает, что они будут исполняться параллельно. В конце концов, если мы добавим 3 таска в последовательную асинхронную очередь, то гарантируется, что все эти три таска будут выполнены один за другим, т.к. у нас только один поток и прежде чем начать новую задачу, мы должны дождаться выполнения предыдущей.

## Operations
GCD хорошо подходит для единоразовых тяжелых тасков, которые должны быть исполнены в бэкграунде. Если речь заходит о reusable функциональности - например, image editing операции, которая должна быть вынесена в отдельный класс, то тут на помощь приходят Operations. 

### Opeartion subclassing
Opeartions - это полностью независимые классы со своей функциональностью, которые могут быть добавлены в OperationQueue точно так же как мы добавляем closures в GCD. Так же они позволяют нам получить свое состояние в любой момент времени. Operation может находиться в любом из нижеперечисленных стейтов:
* isReady
* isExecuting
* isCancelled
* isFinished

Операции по-умолчанию исполняются синхронно. Мы можем запускать их вручную, но это не очень хорошая идея, т.к. это будет влиять на исполнения UI-тасков, которы так же исоплняются в main потоке. Чтобы избежать влияния на UI, мы будем добавлять Operations в OperationQueue. 

Как мы видим, Operations - более гибкий инструмент, который позволяет нам отменять задачи, а так же получать информацию об их текущем состоянии. 

### BlockOperation
Если нам нужно параллельное исполнения задач, то для этого есть наследник класса Operation под названием BlockOperation. Он позволяет запускать несколько closures на default global очереди.
**BlockOpearion всегда исполняется параллельно. Если требуется последовательное исполнение, то лучше исопльзовать GCD**

### Что и когда лучше использовать?
Здесь нет четкого разделения. GCD проще использовать, когда у нас есть небольшие closures или функции, которые нужно исполнить и забыть про них. Если же нам требуется повторно использовать какой-то сложный объект с инкапсуляцией данных и отслеживать его состояние, то лучше исопльзовать Operations.

## Dispatch Queue

### Потоки
Потоки в системе нужны для того, чтобы процесс мог распределить свои задачи по ресурсам системы. Наше iOS приложение - процесс, который исполняет множество задач во множестве потоков. Использование потоков имеет массу преимуществ:
* Ускорение исполнения задач - несколько задач могут исполняться параллельно.
* Отзывчивость - если исполнять всю видимую пользователем UI работу в main UI потоке, а все остальные задачи - в других потоках, то пользователь не заметит, что что-то подвисает. 
* Оптимизированное потребление ресурсов - встроенное управление потоками отлично оптимизируется самой ОС.

Мы могли бы сами заниматься созданием низкоуровневых потоков из Сишной билиотеки libdispatch, но делать этого не стоит. Как минимум потому что ручное управление потоками не такая тривиальная задача, а встроенный механизм GCD хорошо оптимизирован и отлично с этим справляется, не требуя от нас как разработчиков сложной работы. 

### Dispatch queues
